---
title: Рекомендательные системы
weight: 5
---

Задача рекомендательной системы --- найти для пользователя такие
элементы заданного множества, которые с высокой вероятностью понравятся
пользователю.

Введем некоторые обозначения:

-   Пользователи --- множество U (users).

-   Товары --- множество I (items) - товары/фильмы/музыка/техника.

-   Оценки - пусть парам \<пользователь, товар> соответствует некоторая
    оценка $r$, выражающая заинтересованность пользователя в этом товаре
    $r: U \times I \rightarrow R$

Требуется по известным оценкам $r$ для каждого пользователя получить
набор из $k$ товаров, наиболее подходящих пользователю (т.е с
максимальной оценкой $r$). Кроме того, часто влияет и порядок выданных
товаров.

## Модели и признаки

Рассмотрим **baselines** - простые решения, позволяющие сделать
начальную модель, с значениями метрик которой потом будем сравнивать
будущие модели.

Самым очевидным подходом будет найти среднее всех известных оценок $\mu$
и выдавать $\mu$ как ответ, если рейтинг неизвестен.

Этот подход никак не учитывает свойства товара и пользователя. Например
какой-то пользователь может ставить оценки в среднем меньшие, чем
другой.

Давайте найдем для каждого пользователя и товара средние значения
отдельно и найдем, насколько они отличаются от $\mu$:

$$b_u = \mu_u - \mu$$ $$b_i = \mu_i - \mu$$ $$r_{ui} = b_u + b_i + \mu$$

В данный момент мы не учитываем, насколько вкусы пользователей похожи
между собой. Поэтому можем немного модифицировать подсчет среднего:

Будем считать среднее для всех товаров для выбранного пользователя, при
этом влияние других пользователей будет зависеть от их схожести с
выбранным пользователем:

$$\mu_{u_0} = \frac{\sum_U sim(u, u_0) \sum_I r_{ui}}{|Y|}$$

## Похожесть пользователей и товаров

Обозначим за $I_{uv}$ - множество товаров, оценки для которых известны у
пользователей $u$ и $v$ одновременно

Теперь можем посчитать сходство между пользователями c помощью
корреляции Пирсона (либо другой метрики - например, посчитать
какую-нибудь метрику, обратную расстоянию).

$$sim(u, v) = \frac{\sum_{I_{uv}} (r_{ui} - \mu_u)(r_{vi} - \mu_v)}{\sqrt{\sum_{I_{uv}} (r_{ui} - \mu_u)^2 \sum_{I_{uv}} (r_{vi} - \mu_v)^2}}$$

То же самое можно сделать и с товарами.

## Коллаборативная фильтрация

Существуют подходы на основе сходств пользователей и на основе сходств
товаров:

### User-based collaborative filtering

Для текущего пользователя найдем множество пользователей, наиболее
похожих на него: $$U(u_0) = \{u \in U | sim(u_0, u) > \alpha \}$$ Теперь
найдем средние значения оценок для всех товаров у этих пользователей.\
\
\
Проблема данного подхода в том, что он позволяет строить рекомендации
только в том случае, если для данного пользователя существуют похожие на
него. Если же пользователь новый или нетипичный, то подобрать что-либо
не получится.

### Item-based collaborative filtering

Для текущего пользователя найдем множество товаров, наиболее похожих на
заинтересовавшие пользователя.

В таком подходе решается проблема нетипичного пользователя, так как
необязательно иметь пользователей со схожими интересами, и подход
позволяет найти товары, похожие на интересные ему.

Но в таком подходе есть и проблемы: есть вероятность, что вместо
действительно интересных товаров будем рекомендовать популярные.

## Контентные модели

Опишем товары векторами, называемыми **эмбэдингами**. Теперь мы можем
посчитать расстояния в пространстве эмбэдингов. Это позволит нам обучить
модели, которые будут предсказывать целевую переменную на основе
характеристик товара, а не только на основе рейтингов, поставленных
другими пользователями
