---
title: Splay-дерево
authors:
- Григорий Горюнов
editors:
- Сергей Слотин
date: 2021-10-24
weight: 5
---

Splay-дерево — это сбалансированное двоичное дерево поиска, которое ускоряет доступ к недавно использовавшимся вершинам. Оно было придумано в 80-х годах Робертом Тарьяном и [Даниелом Слейтором](https://codeforces.com/profile/Darooha).

Все операции splay-дерева выражаются через одну функцию $splay(v)$, которая делает вершину $v$ корнем.

## Применения

Splay-деревом можно заменять декартово дерево, почти всегда будет прирост скорости, так как в splay-дереве нижняя амортизированная оценка на время операции $\Theta(1)$, а в декартовом — $\Theta(h) \approx \Theta(\log n)$.

На реальных задачах splay-дерево работает почти с такой же скоростью, как и декартово. <!-- возьми задачу на декартач на кф-е и сдай её через splay -->

Splay-дерево можно применять не только как самостоятельную структуру данных, но и как вспомогательную. С использованием splay-деревьев асимптотика Link-Cut дерева улучшается с $O(\log^2 n)$ до $O(\log n)$.

Так же, как и к декартовому дереву, к splay-дереву применима идея [неявного ключа](../implicit).


## Оптимизации доступа

Для доступа к вершине $v$, её необходимо сделать корнем. Это можно сделать разными методами:

* **Move to Root**: поворачиваем ребро $(v; p)$, пока $v$ — не корень. Существует последовательность операций, при которой каждый запрос доступа к вершине будет выполняться за $\Omega(n)$
* **Splay**: различные повороты рядом с вершиной $v$, благодаря чему достигается амортизированная оценка высоты дерева.

Пример: Последовательный доступ сначала к вершине $A$, потом к вершине $B$. Move to Root использовала 6 поворотов для вершины $B$, а splay — всего 3.

![](../img/move_to_root_example.png)

![](../img/splay_example.png)

## Операции с деревом

Основная операция splay-дерева — splay. Через неё можно выразить все остальные операции бинарного дерева поиска.

### splay(v)

Поднять вершину $v$ к корню можно применяя три вида поворотов: zig, zig-zig и zig-zag.

Пусть $p$ — предок $v$, а $g$ — предок $p$ (если $p$ не является корнем).

**zig** Если $p$ корень дерева, то делаем поворот ребра $(v; p)$ и $v$ становится корнем. Zig сокращает глубину $v$ на 1.

**zig-zig**. Если $p$ не корень, а $x$ и $p$ — левый (или правые) дети $p$ и $g$ соответственно, то сначала повернём ребро $(p; g)$, а потом ребро $(v; p)$. Zig-zig сокращает глубину $v$ на 2.

**zig-zag**. Если $p$ не корень, а $x$ — левый сын и $p$ — правый, или наоборот, то сначала повернём ребро $(v; p)$, а потом ребро $(v; g)$. Zig-zag сокращает глубину $v$ на 2.

Асимптотика splay: $O(d)$, где $d$ — изначальная глубина $v$.

### Другие операции

**find(k)**. Поиск элемента как в обычном BST. После нахождения элемента необходимо запустить splay от него.

**merge(T1, T2)**. Пусть все ключи $T_1$ меньше всех ключей $T_2$. Тогда запустим splay от самого правого элемента $T_1$ и подвесим $T_2$ справа к $T_1$.

**split(v)**. Делаем splay(v) и возвращаем два дерева — левое поддерево и исходное дерево без левого сына, или наоборот, в зависимости от знака сравнения.

**add(k)**. Добавить элемент можно двумя способами. Первый: режем дерево по ключу $k$ и подвешиваем поддеревяь правым и левым сыном к новой вершине. Второй: добавляем элемент как в обычном BST и запускаем splay от него.

**delete(k)**. Предположим, что элемент с ключом $k$ существует в дереве. Для удаления ключа делаем splay по ключу $k$ и возвращаем merge его левого и правого сына.

## Реализация

Существует два подхода к реализации splay — снизу и сверху.

### splay "снизу"

В этом походе splay вершины делается при подъёме от самой вершины до корня путем применения поворотов. Для того, чтобы подниматься вверх, необходимо знать предка вершины. Для этого можно просто в вершине хранить ссылку на предка (или запоминать все вершины на пути от корня до искомой).

Будем в вершине хранить индекс левого и правого сына, а также индекс предка (как в дереве отрезков на указателях). Также будем сохранять дополнительную информацию — число вершин в поддереве.

Этот подход удобен там, что код получается напрямую из описания splay-дерева и выглядит хорошо. Если неизвестен индекс целевой вершины, то надо сначала её найти, а потом запустить от неё splay.

Пример реализации — "ordered multiset" через splay-дерево (замена встроенного в gcc ordered_set-а). Поддерживаемые операции:

- `bool contains(int key)`: проверить наличие элемента с ключом $key$.
- `void add(int key)`: добавить элемент с ключом $key$. Эту функцию необходимо изменить, если нужен set, а не multiset.
- `void del(int key)`: удалить элемент с ключом $key$. Если такого элемента нет, ничего не делать.
- `int fbo(int i)`: найти значение элемента с порядковым номером $i$.
- `int ook(int key)`: найти порядковый номер первого элемента с ключом $key$, если бы он был в мультимножестве.

Ленивые операции можно делать как в дереве отрезков. В нужных местах поставлен вызов `push()`.

Данная реализация сравнима по скорости с декартовым деревом (время работы примерно одинаковое). Её можно ускорить, переписав с указателей на массивы.

```cpp
struct SplaySet {
    // Вершина дерева
    struct Node {
        Node *left = 0, *right = 0;  // Индексы левого и правого сына
        Node *par = 0;  // Индекс предка
        int cnt = 1;    // Число вершин в поддереве

        int key = INT_MIN;
        Node(int key = 0) : key(key) {}
    };

    // Корень дерева
    Node* root = 0;

    ~SplaySet() {
        // При очистке дерева надо удалить все вершины
        destroy(root);
    }


    // ==== splay-дерево ====
    // Полное удаление вершины
    void destroy(Node* x) {
        if (!x)
            return;
        destroy(x->left);
        destroy(x->right);
        delete x;
    }

    // Размер поддерева вершины. Если вершины не существует, то 0
    inline int get_count(Node* x) const { return x ? x->cnt : 0; }

    // Проталкивание изменений вниз (как в ленивых операциях)
    inline void push(Node *x) {
        if (!x) return;
    }

    // Поднятие изменений наверх (может также называться upd, relax)
    inline void pull(Node* x) {
        if (!x) return;
        x->cnt = 1 + get_count(x->left) + get_count(x->right);
    }

    // Проверка на корень
    inline bool is_root(Node* x) const { return x && !x->par; }

    // Поворот ребра (x -- x->par)
    // Пересчёт всей дополнительной информации производится при повороте ребра
    // Ребро в дереве можно однозначно определить по его ниждему концу
    // Функция выполняет простой повроот ребра, то есть zig
    inline void rotate(Node* x) {
        Node* p = x->par;
        Node* g = p->par;

        // Обновим информацию в вершинах (проталкивание изменений вниз)
        push(p);
        push(x);

        // Обновим ребенка деда и предка x (обмен x и p)
        if (g) {
            if (g->left == p)
                g->left = x;
            else if (g->right == p)
                g->right = x;
        }
        x->par = g;

        // Переподвешивание поддеревьев
        if (p->left == x) {
            p->left = x->right;
            if (p->left)
                p->left->par = p;
            x->right = p;
        } else {
            p->right = x->left;
            if (p->right)
                p->right->par = p;
            x->left = p;
        }
        p->par = x;

        // Обновим информацию (поднятие изменений наверх)
        pull(p);
        pull(x);
    }

    inline void splay(Node* x) {
        // Пока вершина x -- не корень дерева,
        while (!is_root(x)) {
            Node* p = x->par;
            // Поворачиваем рёбра zig-ом, zig-zig-ом или zig-zag-ом.
            if (!is_root(p)) {
                Node* g = p->par;
                bool zigzig = (x == p->left) == (p == g->left);
                rotate(zigzig ? p : x);
            }
            rotate(x);
        }
        push(x);
    }

    // Самая правая вершина дерева
    Node* rightest(Node* x) const {
        if (!x || !x->right)
            return x;
        return rightest(x->right);
    }

    // Слить два дерева. Ключи левого строго меньше ключей правого
    inline Node* merge(Node* L, Node* R) {
        if (!L) return R;
        if (!R) return L;
        Node* rt = rightest(L);
        splay(rt);
        rt->right = R;
        R->par = rt;
        pull(rt);
        return rt;
    }


    // ==== Функции для работы как с BST ====
    // Найти первую вершину с ключом =key
    inline Node* find(int key) {
        Node* x = root;
        while (x && key != x->key) {
            Node* next = (key > x->key) ? x->right : x->left;
            if (!next) splay(root = x);
            x = next;
        }
        return x;
    }

    // Добавить вершину в дерево
    inline void add(Node* x) {
        if (!root) {
            root = x;
            return;
        }
        Node* y = root;
        while (true) {
            Node*& next = (x->key > y->key) ? y->right : y->left;
            if (!next) {
                next = x, next->par = y;
                splay(root = next);
                return;
            }
            y = next;
        }
    }

    // Удалить вершину из дерева
    inline void del(Node* x) {
        if (!x) return;
        splay(x);
        if (x->left) x->left->par = 0;
        if (x->right) x->right->par = 0;
        root = merge(x->left, x->right);
        delete x;  // не destroy так как одна вершина
    }

    // Найти вершину по её порядковому номеру
    Node* fbo(int i, Node* r) {
        if (!r || i < 0 || i >= get_count(r))
            return 0;  // Такой вершины не существует
        int k = get_count(r->left);
        if (i == k) return splay(r), r;
        else if (i < k) return fbo(i, r->left);
        else return fbo(i - k - 1, r->right);
    }


    // ==== Функции для работы как с сетом ====
    // Проверка наличия элемента
    inline bool contains(int key) {
        Node* r = find(key);
        return r && r->key == key;
    }

    // Добавить элемент с заданным ключом
    inline void add(int key) {
        // Если мультимножество, то проверка не нужна
        if (!contains(key))  // Проверка на дубликат элемента
            add(new Node(key));
    }

    // Удалить элемент по ключу. Если их было несколько, удалить только один
    inline void del(int key) {
        Node* k = find(key);
        if (k && k->key == key)
            del(k);
    }

    // Значение i-того элемента (мульти)множества
    inline int fbo(int i) {
        Node* nd = fbo(i, root);
        if (nd) root = nd;
        return nd ? nd->key : -1;  // -1: такого элемента нет
    }

    // Найти порядковый номер элемента =key, если бы он был в этом множестве
    // Неоптимальная реализация, но зато простая
    inline int ook(int key) {
        Node* q = new Node(key);
        add(q);
        int ans = get_count(q->left);
        del(q);
        return ans;
    }
};
```

### splay "сверху"

Этот подход освобожден от проблемы поиска вершины, поскольку splay одновременно и перестраивает дерево, и ищет вершину. При таком подходе хранить нужно только корень, а остальные вершины сами найдутся.

Описание этого подхода есть на [neerc](https://neerc.ifmo.ru/wiki/index.php?title=Splay-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE#Top-down).
<!-- описание + совместимость с другим подходом -->


## Оценка асимптотики

> TLDR: $T_{splay} = O(\log N)$ в худшем случае.

Заметим, что все операции работают за $O(1) + T(splay)$.

Для анализа асимптотики воспользуемся методом потенциалов. Пусть $s(v)$ — размер поддерева с корнем в вершине $v$, ранг вершины $v$ — $r(v) = \log_2 s(v)$. Потенциалом будет $\Phi = \sum_{v} r(v)$.

Фактическое время $splay(v)$ равно глубине вершины $v$. Оно также равно числу элементарных поворотов, которые необходимы для поднятия вершины $v$.

> Амортизированное время $splay(x)$ (корень дерева — $t$) не превосходит $3r(t) - 3r(x) + 1$.

Доказательство:

Рассмотрим каждый шаг операции splay. Пусть $r$ и $r'$ — до и после шага соответственно. Пусть $p$ — предок $x$, а $g$ — предок $p$ (если $p$ не корень).

### zig

![](../img/zig-left.png)

![](../img/zig-right.png)

Один поворот. Амортизированное время $T = 1 + r'(x) + r'(p) - r(x) - r(p)$.

Так как $r'(p) - r(p) < 0$ (ранг $p$ уменьшился), то $T \le 1 + r'(x) - r(x)$.

Так как $r'(x) - r(x) > 0$ (ранг $x$ увеличился), то $T \le 1 + 3r'(x) - 3r(x)$.

### zig-zig

![](../img/zigzig-left.png)

![](../img/zigzig-right.png)

Два поворота. Амортизированное время $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.

Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.

Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.

Поскольку $r'(p) \le r'(x)$ (теперь $x$ является предком $p$), $T \le 2 + r'(x) + r'(g) - 2r(x)$.

Докажем, что эта сумма не превышает $3r'(x) - 3r(x)$, то есть

$$
2 + r'(x) + r'(g) - 2r(x) \le 3r'(x) - 3r(x)\\
r(x) + r'(g) - 2r'(x) \le -2
$$

Рассмотрим сумму подробнее.

$r(x) + r'(g) - 2r'(x) = (r(x) - r'(x)) + (r'(g) - r'(x)) = \log_2 \displaystyle\frac{s(x)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} = \log_2\left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right)$

Из рисунка выше видно, что $s'(g) + s(x) \le s'(x)$, значит $\displaystyle\frac{s(x)}{s'(x)}+\displaystyle\frac{s'(g)}{s'(x)} \le 1$. По неравенству о средних, если $p + q \le 1$, то $pq \le \displaystyle\frac{1}{4}$.

Так как $\displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \le \displaystyle\frac 14 $, то $\log_2 \left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right) \le -2$, что и является проверяемым неравенством.

### zig-zag

![](../img/zigzag-left.png)

![](../img/zigzag-right.png)

Два поворота. Амортизированное время $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.

Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.

Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.

Докажем, что эта сумма не превышает $2r'(x) - 2r(x)$ (а следовательно, и $3r'(x) - 3r(x)$), то есть

$$
2 + r'(p) + r'(g) - 2r(x) \le 2r'(x) - 2r(x)\\
r'(p) + r'(g) - 2r'(x) \le -2
$$

Так как $r'(p) + r'(g) - 2r'(x) = \log_2\displaystyle\frac{s'(p)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} \le 2$ (аналогично случаю zig-zig), неравенство верно.

Все случаи рассмотрены, во всех случаях утверждение верно.

Так как zig выполняется не более одного раза, то суммарное время всех шагов $T \le 1 + 3r(t) - 3r(x)$ (утроенные ранги промежуточных вершин сокращаются — на одном шаге входят с плюсом, а на следующем — с минусом).

Суммарное время работы $T_{splay} \le 3\log_2 N - 3\log_2 s(x) + 1 = O(\log N)$, где $N$ — число вершин в дереве.

Что и требовалось доказать.

### Другие оценки времени работы

Полученная оценка — оценка __худшего__ случая. На некоторых специальных случаях splay-дерево работает быстрее.

**Теорема о последовательных запросах**. Последовательный доступ к $n$ элеметнам в splay-дереве выполняется за $O(n)$ операций, вне зависимости от изначальной структуры дерева. Наилучшая доказанная оценка — $4.5n$ операций.

<!-- Оптимальность дерева -->


