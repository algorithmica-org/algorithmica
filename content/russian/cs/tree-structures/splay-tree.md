---
title: Splay-дерево
authors:
- Григорий Горюнов
editors:
- Сергей Слотин
date: 2021-10-07
weight: 5
---

Splay-дерево — это сбалансированное двоичное дерево поиска, которое ускоряет доступ к недавно использовавшимся вершинам. Оно было придумано в 80-х годах Робертом Тарьяном и [Даниелом Слейтором](https://codeforces.com/profile/Darooha).

Все операции splay-дерева выражаются через одну функцию $splay(v)$, которая делает вершину $v$ корнем.

## Применения

<!-- Сравнение скорости работы с декартовым деревом -->

Splay-деревом можно заменять декартово дерево, почти всегда будет прирост скорости, так как в splay-дереве нижняя амортизированная оценка на время операции $\Theta(1)$, а в декартовом — $\Theta(h) \approx \Theta(\log n)$.

Сравнение скорости на задаче.

Splay-дерево можно применять не только как самостоятельную структуру данных, но и как вспомогательную. С использованием splay-деревьев асимптотика Link-Cut дерева улучшается с $O(\log^2 n)$ до $O(\log n)$.

Так же, как и к декартовому дереву, к splay-дереву применима идея [неявного ключа](../implicit).


## Оптимизации доступа

Для доступа к вершине $v$, её необходимо сделать корнем. Это можно сделать разными методами:

* **Move to Root**: поворачиваем ребро $(v; p)$, пока $v$ --- не корень. Существует последовательность операций, при которой каждый запрос доступа к вершине будет выполняться за $\Omega(n)$
* **Splay**: различные повороты рядом с вершиной $v$, благодаря чему достигается амортизированная оценка высоты дерева.

Пример: Последовательный доступ сначала к вершине $A$, потом к вершине $B$. Move to Root использовала 6 поворотов для вершины $B$, а splay --- всего 3.

![](../img/move_to_root_example.png)

![](../img/splay_example.png)

## Операции с деревом

Основная операция splay-дерева --- splay. Через неё можно выразить все остальные операции бинарного дерева поиска.

### splay(v)

Поднять вершину $v$ к корню можно применяя три вида поворотов: zig, zig-zig и zig-zag.

Пусть $p$ --- предок $v$, а $g$ --- предок $p$ (если $p$ не является корнем).

**zig** Если $p$ корень дерева, то делаем поворот ребра $(v; p)$ и $v$ становится корнем. Zig сокращает глубину $v$ на 1.

**zig-zig**. Если $p$ не корень, а $x$ и $p$ --- левый (или правые) дети $p$ и $g$ соответственно, то сначала повернём ребро $(p; g)$, а потом ребро $(v; p)$. Zig-zig сокращает глубину $v$ на 2.

**zig-zag**. Если $p$ не корень, а $x$ --- левый сын и $p$ --- правый, или наоборот, то сначала повернём ребро $(v; p)$, а потом ребро $(v; g)$. Zig-zag сокращает глубину $v$ на 2.

Асимптотика splay: $O(d)$, где $d$ --- изначальная глубина $v$.

### Другие операции

**find(k)**. Поиск элемента как в обычном BST. После нахождения элемента необходимо запустить splay от него.

**merge(T1, T2)**. Пусть все ключи $T_1$ меньше всех ключей $T_2$. Тогда запустим splay от самого правого элемента $T_1$ и подвесим $T_2$ справа к $T_1$.

**split(v)**. Делаем splay(v) и возвращаем два дерева --- левое поддерево и исходное дерево без левого сына, или наоборот, в зависимости от знака сравнения.

**add(k)**. Добавить элемент можно двумя способами. Первый: режем дерево по ключу $k$ и подвешиваем поддеревяь правым и левым сыном к новой вершине. Второй: добавляем элемент как в обычном BST и запускаем splay от него.

**delete(k)**. Предположим, что элемент с ключом $k$ существует в дереве. Для удаления ключа делаем splay по ключу $k$ и возвращаем merge его левого и правого сына.

## Реализация

Существует два подхода к реализации splay --- снизу и сверху.

### splay "снизу"

В этом походе splay вершины делается при подъёме от самой вершины до корня путем применения поворотов. Для того, чтобы подниматься вверх, необходимо знать предка вершины. Для этого можно просто в вершине хранить ссылку на предка (или запоминать все вершины на пути от корня до искомой).

Будем в вершине хранить индекс левого и правого сына, а также индекс предка (как в дереве отрезков на указателях). Также будем сохранять дополнительную информацию --- число вершин в поддереве.

Этот подход удобен там, что код получается напрямую из описания splay-дерева и выглядит хорошо. Если неизвестен индекс целевой вершины, то надо сначала её найти, а потом запустить от неё splay.

```cpp
struct Node {
    int left = -1, right = -1;  // Индексы левого и правого сына
    int par = -1;  // Индекс предка
    int cnt = 1;  // Число вершин в поддереве

    int key;
};

vector<Node> t;  // массив всех вершин
int last_index = 0;

int splay(int x) {
    // Пока вершина x -- не корень дерева,
    while (!is_root(x)) {
        int p = t[x].par;
        // Поворачиваем рёбра zig-ом, zig-zig-ом или zig-zag-ом.
        if (!is_root(p)) {
            int g = t[p].par;
            bool zigzig = (x == t[p].left) == (p == t[g].left);
            rotate(zigzig ? p : x);
        }
        rotate(x);
    }
    push(x);
    return x;
}

bool is_root(int x) {
    return t[x].par == -1;
}

// Пересчёт всей дополнительной информации производится при повороте ребра
// Ребро в дереве можно однозначно определить по его ниждему концу
// Функция выполняет простой повроот ребра, то есть zig
void rotate(int x) {
    int p = t[x].par;
    int g = t[p].par;

    // Обновим информацию в вершинах (проталкивание изменений вниз)
    push(p);
    push(x);

    // Обновим ребенка деда и предка x (обмен x и p)
    if (g != -1) {
        if (t[g].left == p)
            t[g].left = x;
        else if (t[g].right == p)
            t[g].right = x;
    }
    t[x].par = g;

    // Переподвешивание поддеревьев
    if (t[p].left == x) {
        //     P           X
        //    / \         / \
        //   X   C  -->  A   P
        //  / \             / \
        // A   B           B   C
        t[p].left = t[x].right;
        if (t[p].left != -1)
          t[t[p].left].par = p;
        t[x].right = p;
    } else {
        //   P              X
        //  / \            / \
        // A   X    -->   P   C
        //    / \        / \
        //   B   C      A   B
        t[p].right = t[x].left;
        if (t[p].right != -1)
          t[t[p].right].par = p;
        t[x].left = p;
    }
    t[p].par = x;

    // Обновим информацию (поднятие изменений наверх)
    pull(p);
    pull(x);
}

// Размер поддерева вершины. Если вершины не существует, то 0
int get_count(int x) {
    return x != -1 ? t[x].cnt : 0;
}

// Проталкивание изменений вниз
void push(int x) {
    if (x == -1)
        return;
}

// Поднятие изменений наверх
void pull(int x) {
    if (x == -1)
        return;
    t[x].cnt = 1 + get_count(t[x].left) + get_count(t[x].right);
}


// Функции для работы со splay-деревом как с BST

int find(int key, int root) {
    if (root == -1)
        return -1;
    if (t[root].key == key)
        return splay(root);
    return (t[root].key < key) ? find(key, t[root].left) : find(key, t[root].right);
}

// Все ключи левого дерева меньше всех ключей правого
int merge(int L, int R) {
    if (L == -1) return R;
    if (R == -1) return L;
    while (t[L].right != -1) {
        L = t[L].right;
    }
    splay(L);
    t[L].right = R;
    return L;
}

// В левом поддереве все ключи < key, в правом -- все >= key
pair<int, int> split(int key, int root) {
    if (root == -1)
        return { -1, -1 };
    splay(root);
    int L = t[root].left;
    int R = root;
    t[R].left = t[L].par = -1;
    return { L, R };
}

int add(int key, int root) {
    if (-1 != find(key, root))
        return root;
    auto &&[L, R] = split(key, root);
    int i = last_index++;
    t[i].key = key;
    t[i].left = L;
    t[i].right = R;
    t[L].par = t[R].par = i;
    return i;
}

int delete(int key, int root) {
    int v = find(key, root);
    if (-1 == v)
        return root;

    // Удаление вершины
    int i = --last_index;
    if (t[i].par != -1) {
        if (t[t[i].par].left == i)
            t[t[i].par].left = v;
        else
            t[t[i].par].right = v;
    }
    if (t[i].left != -1)
        t[t[i].left].par = v;
    if (t[i].right != -1)
        t[t[i].right].par = v;
    swap(t[v], t[i]);  // Теперь посделняя вершина на месте удалённой

    return merge(t[i].left, t[i].right);
}
```

### splay "сверху"

Этот подход освобожден от проблемы поиска вершины, поскольку splay одновременно и перестраивает дерево, и ищет вершину.

Описание этого подхода есть на neerc.ifmo.ru
<!-- описание + совместимость с другим подходом -->


## Оценка асимптотики

TLDR: $T_{splay} = O(\log N)$ в худшем случае.

Заметим, что все операции работают за $O(1) + T(splay)$.

Для анализа асимптотики воспользуемся методом потенциалов. Пусть $s(v)$ --- размер поддерева с корнем в вершине $v$, ранг вершины $v$ --- $r(v) = \log_2 s(v)$. Потенциалом будет $\Phi = \sum_{v} r(v)$.

Фактическое время $splay(v)$ равно глубине вершины $v$. Оно также равно числу элементарных поворотов, которые необходимы для поднятия вершины $v$.

> Амортизированное время $splay(x)$ (корень дерева --- $t$) не превосходит $3r(t) - 3r(x) + 1$.

Доказательство:

Рассмотрим каждый шаг операции splay. Пусть $r$ и $r'$ --- до и после шага соответственно. Пусть $p$ --- предок $x$, а $g$ --- предок $p$ (если $p$ не корень).

### zig

![](../img/zig-left.png)

![](../img/zig-right.png)

Один поворот. Амортизированное время $T = 1 + r'(x) + r'(p) - r(x) - r(p)$.

Так как $r'(p) - r(p) < 0$ (ранг $p$ уменьшился), то $T \le 1 + r'(x) - r(x)$.

Так как $r'(x) - r(x) > 0$ (ранг $x$ увеличился), то $T \le 1 + 3r'(x) - 3r(x)$.

### zig-zig

![](../img/zigzig-left.png)

![](../img/zigzig-right.png)

Два поворота. Амортизированное время $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.

Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.

Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.

Поскольку $r'(p) \le r'(x)$ (теперь $x$ является предком $p$), $T \le 2 + r'(x) + r'(g) - 2r(x)$.

Докажем, что эта сумма не превышает $3r'(x) - 3r(x)$, то есть

$$
2 + r'(x) + r'(g) - 2r(x) \le 3r'(x) - 3r(x)\\
r(x) + r'(g) - 2r'(x) \le -2
$$

Рассмотрим сумму подробнее.

$r(x) + r'(g) - 2r'(x) = (r(x) - r'(x)) + (r'(g) - r'(x)) = \log_2 \displaystyle\frac{s(x)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} = \log_2\left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right)$

Из рисунка выше видно, что $s'(g) + s(x) \le s'(x)$, значит $\displaystyle\frac{s(x)}{s'(x)}+\displaystyle\frac{s'(g)}{s'(x)} \le 1$. По неравенству о средних, если $p + q \le 1$, то $pq \le \displaystyle\frac{1}{4}$.

Так как $\displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \le \displaystyle\frac 14 $, то $\log_2 \left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right) \le -2$, что и является проверяемым неравенством.

### zig-zag

![](../img/zigzag-left.png)

![](../img/zigzag-right.png)

Два поворота. Амортизированное время $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.

Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.

Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.

Докажем, что эта сумма не превышает $2r'(x) - 2r(x)$ (а следовательно, и $3r'(x) - 3r(x)$), то есть

$$
2 + r'(p) + r'(g) - 2r(x) \le 2r'(x) - 2r(x)\\
r'(p) + r'(g) - 2r'(x) \le -2
$$

Так как $r'(p) + r'(g) - 2r'(x) = \log_2\displaystyle\frac{s'(p)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} \le 2$ (аналогично случаю zig-zig), неравенство верно.

Все случаи рассмотрены, во всех случаях утверждение верно.

Так как zig выполняется не более одного раза, то суммарное время всех шагов $T \le 1 + 3r(t) - 3r(x)$ (утроенные ранги промежуточных вершин сокращаются --- на одном шаге входят с плюсом, а на следующем --- с минусом).

Суммарное время работы $T_{splay} \le 3\log_2 N - 3\log_2 s(x) + 1 = O(\log N)$, где $N$ --- число вершин в дереве.

Что и требовалось доказать.

### Другие оценки времени работы

Полученная оценка --- оценка __худшего__ случая. На некоторых специальных случаях splay-дерево работает быстрее.

**Теорема о последовательных запросах**. Последовательный доступ к $n$ элеметнам в splay-дереве выполняется за $O(n)$ операций, вне зависимости от изначальной структуры дерева. Наилучшая доказанная оценка --- $4.5n$ операций.

<!-- Оптимальность дерева -->


