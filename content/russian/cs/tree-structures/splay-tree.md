---
title: Splay-дерево
authors:
- Григорий Горюнов
draft: true
# Оптимальность дерева, splay сверху
---

Splay-дерево --- это самобалансирующееся двоичное дерево поиска, которое ускоряет доступ к недавно использовавшимся вершинам. Оно было придумано в 80-х годах Робертом Тарьяном и Даниелем Слейтером.

Все операции splay-дерева выражаются через одну функцию $splay(v)$, которая делает вершину $v$ корнем.

## Оптимизации доступа

Для доступа к вершине $v$, её необходимо сделать корнем. Это можно сделать разными методами:

* **Move to Root**: поворачиваем ребро $(v; p)$, пока $v$ --- не корень. Существует последовательность операций, при которой каждый запрос доступа к вершине будет выполняться за $\Omega(n)$
* **Splay**: различные повороты рядом с вершиной $v$, благодаря чему достигается амортизированная оценка высоты дерева.

Пример: Последовательный доступ сначала к вершине $A$, потом к вершине $B$. Move to Root использовала 6 поворотов для вершгины $B$, а splay --- всего 3.

![](../img/move_to_root_example.png)

![](../img/splay_example.png)

## Операции с деревом

### splay(v)

Поднять вершину $v$ к корню можно применяя три вида поворотов: zig, zig-zig и zig-zag.

Пусть $p$ --- предок $v$, а $g$ --- предок $p$ (если $p$ не является корнем).

**zig**. Если $p$ корень дерева, то делаем поворот ребра $(v; p)$ и $v$ становится корнем. Zig сокращает глубину $v$ на 1.

![](../img/zig-left.png)

![](../img/zig-right.png)

**zig-zig**. Если $p$ не корень, а $x$ и $p$ --- левый (или правые) дети $p$ и $g$ сответственно, то сначала повернём ребро $(p; g)$, а потом ребро $(v; p)$. Zig-zig сокращает глубину $v$ на 2.

![](../img/zigzig-left.png)

![](../img/zigzig-right.png)

**zig-zag**. Если $p$ не корень, а $x$ --- левый сын и $p$ --- правый, или наоборот, то сначала повернём ребро $(v; p)$, а потом ребро $(v; g)$. Zig-zag сокращает глубину $v$ на 2.

![](../img/zigzag-left.png)

![](../img/zigzag-right.png)

Асимптотика splay: $O(d)$, где $d$ --- изначальная глубина $v$.

### find(k)

Поиск элемента как в обычном BST. После нахождения элемента необходимо запустить splay от него.

### merge(T1, T2)

Пусть все ключи $T_1$ меньше всех ключей $T_2$. Тогда запустим splay от самого правого элемента $T_1$ и подвесим $T_2$ справа к $T_1$.

### split(v)

Делаем splay(v) и возвращаем два дерева --- левое поддерево и исходное дерево без левого сына, или наоборот, в зависимости от знака сравнения.

### add(k)

Для добавления элемента есть два подхода.

Первый: режем дерево по ключу $k$ и подвешиваем поддеревяь правым и левым сыном к новой вершине.

Второй: добавляем элемент как в обычном BST и запускаем splay от него.

### delete(k)

Предположим, что элемент с ключом $k$ существует в дереве. Для удаления ключа делаем splay по ключу $k$ и возвращаем merge его левого и правого сына.

## Оценка асимптотики

TLDR: $T_{splay} = O(\log N)$ в __худшем__ случае.

Заметим, что все операции работают за $O(1) + T(splay)$.

Для анализа асимптотики воспользуемся методом потенциалов. Пусть $s(v)$ --- размер поддерева с корнем в вершине $v$, ранг вершины $v$ --- $r(v) = \log_2 s(v)$. Потенциалом будет $\Phi = \sum_{v} r(v)$.

Фактическое время $splay(v)$ равно глубине вершины $v$. Оно также равно числу элементарных поворотов, которые необходимы для поднятия вершины $v$.

> Амортизированное время $splay(x)$ (корень дерева --- $t$) не превосходит $3r(t) - 3r(x) + 1$.

Доказательство:

Рассмотрим каждый шаг операции splay. Пусть $r$ и $r'$ --- до и после шага соответственно. Пусть $p$ --- предок $x$, а $g$ --- предок $p$ (если $p$ не корень).

Картинки для пристального взгляда находятся выше.

**zig**. Один поворот, значит, амортизированное время будет $T = 1 + r'(x) + r'(p) - r(x) - r(p)$.
Так как $r'(p) - r(p) < 0$ (ранг $p$ уменьшился), то $T \le 1 + r'(x) - r(x)$.
Так как $r'(x) - r(x) > 0$ (ранг $x$ увеличился), то $T \le 1 + 3r'(x) - 3r(x)$.

**zig-zig**. Два поворота, значит, амортизированное время будет $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.
Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.
Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.
Поскольку $r'(p) \le r'(x)$ (теперь $x$ является предком $p$), $T \le 2 + r'(x) + r'(g) - 2r(x)$.
Докажем, что эта сумма не превышает $3r'(x) - 3r(x)$, то есть

$$
2 + r'(x) + r'(g) - 2r(x) &\le 3r'(x) - 3r(x)\\
r(x) + r'(g) - 2r'(x) &\le -2
$$

Рассмотрим сумму подробнее.

$r(x) + r'(g) - 2r'(x) = (r(x) - r'(x)) + (r'(g) - r'(x)) = \log_2 \displaystyle\frac{s(x)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} = \log_2\left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right)$

Из рисунка выше видно, что $s'(g) + s(x) \le s'(x)$ ($(1 + s(a) + s(b)) + (1 + s(c) + s(d)) \le (3 + s(a) + s(b) + s(c) + s(d))$), значит $\displaystyle\frac{s(x)}{s'(x)}+\displaystyle\frac{s'(g)}{s'(x)} \le 1$. По неравенству о средних, если $p + q \le 1$, то $pq \le \df{1}{4}$.

Так как $\displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \le \df14$, то $\log_2 \left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right) \le -2$, что и является проверяемым неравенством.

**zig-zag**. Два поворота, значит, амортизированное время будет $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.
Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.
Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.
Докажем, что эта сумма не превышает $2r'(x) - 2r(x)$ (а следовательно, и $3r'(x) - 3r(x)$), то есть

$$
2 + r'(p) + r'(g) - 2r(x) &\le 2r'(x) - 2r(x)\\
r'(p) + r'(g) - 2r'(x) &\le -2
$$

Так как $r'(p) + r'(g) - 2r'(x) = \log_2\displaystyle\frac{s'(p)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} \le 2$ (аналогично случаю zig-zig), неравенство верно.

Все случаи рассмотрены, во всех случаях утверждение верно.

Так как zig выполняется не более одного раза, то суммарное время всех шагов $T \le 1 + 3r(t) - 3r(x)$ (утроенные ранги промежуточных вершин сокращаются --- на одном шаге входят с плюсом, а на следующем --- с минусом).

Суммарное время работы $T_{splay} \le 3\log_2 N - 3\log_2 s(x) + 1 = O(\log N)$, где $N$ --- число вершин в дереве.

Что и требовалось доказать.

Но эта оценка --- оценка __худшего__ случая. На некоторых специальных случаях splay-дерево работает быстрее.

**Теорема о последовательных запросах**. Последовательный доступ к $n$ элеметнам в splay-дереве выполняется за $O(n)$ операций, вне зависимости от изначальной структуры дерева. Наилучшая доказанная оценка --- $4.5n$ операций.

<!-- Оптимальность дерева -->

## Реализация

Существует два подхода к реализации splay --- снизу и сверху.

### splay "снизу"

В этом походе splay вершины делается при подъёме от самой вершины до корня путем применения поворотов. Для того, чтобы подниматься вверх, необходимо знать предка вершины. Для этого можно просто в вершине хранить ссылку на предка (или запоминать все вершины на пути от корня до искомой).

Будем в вершине хранить индекс левого и правого сына, а также индекс предка (как в дереве отрезков на указателях). Также будем сохранять дополнительную информацию --- число вершин в поддереве.

```cpp
struct Node {
  int left = -1, right = -1;  // Индексы левого и правого сына
  int par = -1;  // Индекс предка
  int cnt = 1;  // Число вершин в поддереве
};

vector<Node> t;  // массив всех вершин
```

splay при таком подходе делается просто:

```cpp
void splay(int x) {
  while (!is_root(x)) {
    int p = t[x].par;
    if (!is_root(p)) {
      int g = t[p].par;
      bool zigzig = (x == t[p].left) == (p == t[g].left);
      rotate(zigzig ? p : x);
    }
    rotate(x);
  }
  push(x);
}
```

Пока вершина $x$ --- не корень дерева, поворачиваем рёбра zig-ом, zig-zig-ом или zig-zag-ом. Ребро в дереве определяется нижним его концом, поэтому `rotate` принимает только один аргумент.

Проверка на корень очень проста --- нужно проверить существование предка вершины.

```cpp
bool is_root(int x) {
  return t[x].par == -1;
}
```

Пересчёт всей дополнительной информации делается при повороте ребра.

```cpp
void rotate(int x) {
  int p = t[x].par;
  int g = t[p].par;

  // Обновим информацию в вершинах (проталкивание изменений вниз)
  push(p);
  push(x);

  // Обновим ребенка деда и предка x (обмен x и p)
  if (g != -1) {
    if (t[g].left == p)
      t[g].left = x;
    else if (t[g].right == p)
      t[g].right = x;
  }
  t[x].par = g;

  // Переподвешивание поддеревьев
  if (t[p].left == x) {
    //     P           X
    //    / \         / \
    //   X   C  -->  A   P
    //  / \             / \
    // A   B           B   C
    t[p].left = t[x].right;
    if (t[p].left != -1)
      t[t[p].left].par = p;
    t[x].right = p;
  } else {
    //   P              X
    //  / \            / \
    // A   X    -->   P   C
    //    / \        / \
    //   B   C      A   B
    t[p].right = t[x].left;
    if (t[p].right != -1)
      t[t[p].right].par = p;
    t[x].left = p;
  }
  t[p].par = x;

  // Обновим информацию (поднятие изменений наверх)
  pull(p);
  pull(x);
}
```

Функции пересчёта размера поддеревьев.

```cpp
// Размер поддерева вершины. Если вершины не существует, то 0
int get_count(int x) {
  return x != -1 ? t[x].cnt : 0;
}

// Проталкивание изменений вниз
void push(int x) {
  if (x == -1)
    return;
}

// Поднятие изменений наверх
void pull(int x) {
  if (x == -1)
    return;
  t[x].cnt = 1 + get_count(t[x].left) + get_count(t[x].right);
}
```

Этот подход удобен там, что код получается напрямую из описания splay-дерева и выглядит хорошо. Если неизвестен индекс целевой вершины, то надо сначала её найти, а потом запустить от неё splay.

### splay "сверху"

Этот подход освобожден от проблемы поиска вершины, поскольку splay одновременно и перестраивает дерево, и ищет вершину.

<!-- описание + совместимость с другим подходом -->

## Применения

Splay-деревом можно заменять декартово дерево, почти всегда будет прирост скорост, так как в splay-дереве нижняя амортизированная оценка на время операции $\Theta(1)$, а в декартовом --- $\Theta(h) \approx \Theta(\log n)$.

Splay-дерево можно применять не только как самостоятельную структуру данных, но и как вспомогательную. С использованием splay-деревьев асимптотика Link-Cut дерева улучшается с $O(\log^2 n)$ до $O(\log n)$.

Так же, как и к декартовому дереву, к splay-дереву применима идея "неявного ключа".
