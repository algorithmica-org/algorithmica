---
title: Splay-дерево
authors:
- Григорий Горюнов
draft: true
---

Splay-дерево --- это самобалансирующееся двоичное дерево поиска, которое ускоряет доступ к недавно использовавшимся вершинам. Оно было придумано в 80-х годах Робертом Тарьяном и Даниелем Слейтером.

Все операции splay-дерева выражаются через одну функцию $splay(v)$, которая делает вершину $v$ корнем.

## Оптимизации доступа

Для доступа к вершине $v$, её необходимо сделать корнем. Это можно сделать разными методами:

* **Move to Root**: поворачиваем ребро $(v; p)$, пока $v$ --- не корень. Существует последовательность операций, при которой каждый запрос доступа к вершине будет выполняться за $\Omega(n)$
* **Splay**: различные повороты рядом с вершиной $v$, благодаря чему достигается амортизированная оценка высоты дерева.

Пример: Последовательный доступ сначала к вершине $A$, потом к вершине $B$. Move to Root использовала 6 поворотов для вершгины $B$, а splay --- всего 3.

![](../img/move_to_root_example.png)

![](../img/splay_example.png)

## Операции с деревом

### splay(v)

Поднять вершину $v$ к корню можно применяя три вида поворотов: zig, zig-zig и zig-zag.

Пусть $p$ --- предок $v$, а $g$ --- предок $p$ (если $p$ не является корнем).

#### zig

Если $p$ корень дерева, то делаем поворот ребра $(v; p)$ и $v$ становится корнем. Zig сокращает глубину $v$ на 1.

![](../img/zig-left.png)

![](../img/zig-right.png)

#### zig-zig

Если $p$ не корень, а $x$ и $p$ --- левый (или правые) дети $p$ и $g$ сответственно, то сначала повернём ребро $(p; g)$, а потом ребро $(v; p)$. Zig-zig сокращает глубину $v$ на 2.

![](../img/zigzig-left.png)

![](../img/zigzig-right.png)

#### zig-zag

Если $p$ не корень, а $x$ --- левый сын и $p$ --- правый, или наоборот, то сначала повернём ребро $(v; p)$, а потом ребро $(v; g)$. Zig-zag сокращает глубину $v$ на 2.

![](../img/zigzag-left.png)

![](../img/zigzag-right.png)

Асимптотика splay: $O(d)$, где $d$ --- изначальная глубина $v$.

### find(k)

Поиск элемента как в обычном BST. После нахождения элемента необходимо запустить splay от него.

### merge(T1, T2)

Пусть все ключи $T_1$ меньше всех ключей $T_2$. Тогда запустим splay от самого правого элемента $T_1$ и подвесим $T_2$ справа к $T_1$.

### split(v)

Делаем splay(v) и возвращаем два дерева --- левое поддерево и исходное дерево без левого сына, или наоборот, в зависимости от знака сравнения.

### add(k)

Для добавления элемента есть два подхода.

Первый: режем дерево по ключу $k$ и подвешиваем поддеревяь правым и левым сыном к новой вершине.

Второй: добавляем элемент как в обычном BST и запускаем splay от него.

### delete(k)

Предположим, что элемент с ключом $k$ существует в дереве. Для удаления ключа делаем splay по ключу $k$ и возвращаем merge его левого и правого сына.

## Оценка асимптотики

TLDR: $T_{splay} = O(\log N)$ в __худшем__ случае.

Заметим, что все операции работают за $O(1) + T(splay)$.

Для анализа асимптотики воспользуемся методом потенциалов. Пусть $s(v)$ --- размер поддерева с корнем в вершине $v$, ранг вершины $v$ --- $r(v) = \log_2 s(v)$. Потенциалом будет $\Phi = \sum_{v} r(v)$.

Фактическое время $splay(v)$ равно глубине вершины $v$. Оно также равно числу элементарных поворотов, которые необходимы для поднятия вершины $v$.

> Амортизированное время $splay(x)$ (корень дерева --- $t$) не превосходит $3r(t) - 3r(x) + 1$.

Доказательство:

Рассмотрим каждый шаг операции splay. Пусть $r$ и $r'$ --- до и после шага соответственно. Пусть $p$ --- предок $x$, а $g$ --- предок $p$ (если $p$ не корень).

Картинки для пристального взгляда находятся выше.

**zig**. Один поворот, значит, амортизированное время будет $T = 1 + r'(x) + r'(p) - r(x) - r(p)$.
Так как $r'(p) - r(p) < 0$ (ранг $p$ уменьшился), то $T \le 1 + r'(x) - r(x)$.
Так как $r'(x) - r(x) > 0$ (ранг $x$ увеличился), то $T \le 1 + 3r'(x) - 3r(x)$.

**zig-zig**. Два поворота, значит, амортизированное время будет $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.
Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.
Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.
Поскольку $r'(p) \le r'(x)$ (теперь $x$ является предком $p$), $T \le 2 + r'(x) + r'(g) - 2r(x)$.
Докажем, что эта сумма не превышает $3r'(x) - 3r(x)$, то есть

$$
2 + r'(x) + r'(g) - 2r(x) &\le 3r'(x) - 3r(x)\\
r(x) + r'(g) - 2r'(x) &\le -2
$$

Рассмотрим сумму подробнее.

$r(x) + r'(g) - 2r'(x) = (r(x) - r'(x)) + (r'(g) - r'(x)) = \log_2 \displaystyle\frac{s(x)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} = \log_2\left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right)$

Из рисунка выше видно, что $s'(g) + s(x) \le s'(x)$ ($(1 + s(a) + s(b)) + (1 + s(c) + s(d)) \le (3 + s(a) + s(b) + s(c) + s(d))$), значит $\displaystyle\frac{s(x)}{s'(x)}+\displaystyle\frac{s'(g)}{s'(x)} \le 1$. По неравенству о средних, если $p + q \le 1$, то $pq \le \df{1}{4}$.

Так как $\displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \le \df14$, то $\log_2 \left( \displaystyle\frac{s(x)}{s'(x)} \cdot \displaystyle\frac{s'(g)}{s'(x)} \right) \le -2$, что и является проверяемым неравенством.

**zig-zag**. Два поворота, значит, амортизированное время будет $T = 2 + r'(x) + r'(p) + r'(g) - r(p) - r(x) - r(g)$.
Поскольку $r'(x) = r(g)$ ($x$ станет новым корнем), значит, $T = 2 + r'(p) + r'(g) - r(x) - r(p)$.
Поскольку $r(x) \le r(p)$ ($p$ является предком $x$), $T \le 2 + r'(p) + r'(g) - 2r(x)$.
Докажем, что эта сумма не превышает $2r'(x) - 2r(x)$ (а следовательно, и $3r'(x) - 3r(x)$), то есть

$$
2 + r'(p) + r'(g) - 2r(x) &\le 2r'(x) - 2r(x)\\
r'(p) + r'(g) - 2r'(x) &\le -2
$$

Так как $r'(p) + r'(g) - 2r'(x) = \log_2\displaystyle\frac{s'(p)}{s'(x)} + \log_2\displaystyle\frac{s'(g)}{s'(x)} \le 2$ (аналогично случаю zig-zig), неравенство верно.

Все случаи рассмотрены, во всех случаях утверждение верно.

Так как zig выполняется не более одного раза, то суммарное время всех шагов $T \le 1 + 3r(t) - 3r(x)$ (утроенные ранги промежуточных вершин сокращаются --- на одном шаге входят с плюсом, а на следующем --- с минусом).

Суммарное время работы $T_{splay} \le 3\log_2 N - 3\log_2 s(x) + 1 = O(\log N)$, где $N$ --- число вершин в дереве.

Что и требовалось доказать.

Но эта оценка --- оценка __худшего__ случая. На некоторых специальных случаях splay-дерево работает быстрее.

**Теорема о последовательных запросах**. Последовательный доступ к $n$ элеметнам в splay-дереве выполняется за $O(n)$ операций, вне зависимости от изначальной структуры дерева. Наилучшая доказанная оценка --- $4.5n$ операций.

<!-- Оптимальность дерева -->

## Реализация

> bottom-up

> top-down

## Применения

Splay-дерево можно применять не только как самостоятельную структуру данных, но и как вспомогательную. С использованием splay-деревьев асимптотика Link-Cut дерева улучшается с $O(\log^2 n)$ до $O(\log n)$.

Так же, как и к декартовому дереву, к splay-дереву применима идея "неявного ключа"
