---
title: Поиск в ширину
authors:
- Максим Иванов
- Станислав Алексеев
weight: 2
draft: false
---

*Поиск в ширину* (англ. *breadth-first search*) — это один из основных алгоритмов на графах.

Поиск в ширину также называется *обходом* — так же, как поиск в глубину и все другие обходы, он посещает все вершины графа по одному разу, только в другом порядке.

В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер.

Алгоритм работает за $O (n+m)$, где $n$ — число вершин, $m$ — число рёбер.

## Описание алгоритма

На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины $s$. Граф может быть как ориентированным, так и неориентированным, для алгоритма это не важно.

Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину $s$. На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).

Более строго это можно представить следующим образом. Создадим очередь q, в которую будут помещаться горящие вершины, а также заведём булевский массив $used$, в котором для каждой вершины будем отмечать, горит она уже или нет (или иными словами, была ли она посещена).

Изначально в очередь помещается только вершина $s$, и $used[s]$ помечается, как $true$, а для остальных, как $false$. Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и поместить в конец очереди.

В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей $d[v]$), и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести массив "предков" $p[v]$, в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).

Реализация
Реализуем вышеописанный алгоритм на языке C++.

Входные данные:

``` c++
vector <vector<int>> g; // граф
int n; // число вершин

// Сам обход:
void bfs(int s) {
    queue<int> q;
    vector<int> d(n, -1), p(n);
    q.push (s);
    p[s] = -1;
    d[s] = 0;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (auto to: g[v]) {
            if (d[to] == -1) {
                q.push (to);
                d[to] = d[v] + 1;
                p[to] = v;
            }
        }
    }
} 
```


Если теперь надо восстановить и вывести кратчайший путь до какой-то вершины $to$, это можно сделать следующим образом:

```c++
if (!used[to])
	cout << "No path!";
else {
	vector<int> path;
	for (int v = to; v != -1; v = p[v])
		path.push_back(v);
	reverse(path.begin(), path.end());
	cout << "Path: ";
	for (int i = 0; i < path.size(); ++i)
		cout << path[i] + 1 << " ";
}
```

## Применения алгоритма

- Поиск кратчайшего пути в невзвешенном графе.
- Поиск компонент связности в графе за O(n+m).
  Для этого мы просто запускаем обход в ширину от каждой вершины, за исключением вершин, оставшихся посещёнными после предыдущих запусков. Таким образом, мы выполняем обычный запуск в ширину от каждой вершины, но не обнуляем каждый раз массив $used$, за счёт чего мы каждый раз будем обходить новую компоненту связности, а суммарное время работы алгоритма составит по-прежнему $O(n+m)$ (такие несколько запусков обхода на графе без обнуления массива $used$ называются серией обходов в ширину).

- Нахождения решения какой-либо задачи (игры) с наименьшим числом ходов, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — рёбрами графа.
  Классический пример — игра, где робот двигается по полю, при этом он может передвигать ящики, находящиеся на этом же поле, и требуется за наименьшее число ходов передвинуть ящики в требуемые позиции. Решается это обходом в ширину по графу, где состоянием (вершиной) является набор координат: координаты робота, и координаты всех коробок.

- Нахождение кратчайшего пути в 0-1-графе (т.е. графе взвешенном, но с весами равными только 0 либо 1): будет рассмотрено далее.
- Нахождение кратчайшего цикла в ориентированном невзвешенном графе: производим поиск в ширину из каждой вершины; как только в процессе обхода мы пытаемся пойти из текущей вершины по какому-то ребру в уже посещённую вершину, то это означает, что мы нашли кратчайший цикл, и останавливаем обход в ширину; среди всех таких найденных циклов (по одному от каждого запуска обхода) выбираем кратчайший.
- Найти все рёбра, лежащие на каком-либо кратчайшем пути между заданной парой вершин $(a,b)$. Для этого надо запустить 2 поиска в ширину: из $a$, и из $b$. Обозначим через $d_a$ массив кратчайших расстояний, полученный в результате первого обхода, а через $d_b$ — в результате второго обхода. Теперь для любого ребра $(u,v)$ легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие $d_a[u] + 1 + d_b[v] = d_a[b]$.
- Найти все вершины, лежащие на каком-либо кратчайшем пути между заданной парой вершин $(a,b)$. Аналогично предыдущему пункту запустим два обхода в ширину: из $a$ и из $b$. Теперь для любой вершины v легко проверить, лежит ли она на каком-либо кратчайшем пути: критерием будет условие $d_a[v] + d_b[v] = d_a[b]$.
- Найти кратчайший чётный путь в графе (т.е. путь чётной длины). Для этого надо построить вспомогательный граф, вершинами которого будут состояния $(v,c)$, где $v$ — номер текущей вершины, $c \in \{0,1\}$ — текущая чётность. Любое ребро $(a,b)$ исходного графа в этом новом графе превратится в два ребра $((u,0),(v,1))$ и $((u,1),(v,0))$. После этого на этом графе надо обходом в ширину найти кратчайший путь из стартовой вершины в конечную, с чётностью, равной 0.

# 0-1 BFS

Задача: вам дан взвешенный граф $G$, веса рёбер которого принимают значения $0$ ($0$-рёбра) и $1$ ($1$-рёбра) и выделена вершина $v$ в нём. Вас просят найти в этом графе кратчайшие расстояния от $v$ до всех остальных вершин.

**Идея:** если от вершины $v_1$ до вершины $v_2$ можно дойти по пути, состоящему из рёбер веса $0$, то кратчайшие расстояния до этих вершин совпадают.

Заметим тогда, что если в нашем графе оставить только $0$-рёбра, то он распадётся на компоненты связности (возможно, некоторые будут иметь размер $1$), в каждой из которых ответ одинаковый. Если теперь
вернуть $1$-рёбра, и сказать, что эти рёбра соединяют не вершины,
а компоненты связности, то мы сведём задачу к обычному
$\textbf{BFS}$-у.

А чтобы решить исходную задачу, надо при посещении первой вершины из компоненты обойти всю компоненту, проставив во всех вершинах такой же ответ, как и у первой вершины. Как же можно обойти всю компоненту?
Запустить $\textbf{BFS}$ на $0$-рёбрах\!

А теперь заметим, что на самом деле нам не нужно запускать $\textbf{BFS}$ внутри $\textbf{BFS}$, достаточно при посещении вершины
добавлять всех её непосещённых соседей по $0$-ребрам в голову очереди,чтобы обработать их раньше, чем следующие в очереди. Это можно делать, допустим, с помощью дека.

В итоге, наш алгоритм выглядит примерно так:

``` C++
vector<int> zero_one_bfs(int s) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n <=> v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    deque<int> q;
    q.push_back(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop_front();
        for (auto [to, w] /* конец ребра и его вес */ : g[v]) {
            if (dist[to] > dist[v] + w) {
                dist[to] = dist[v] + w;
                if (w == 0) {
                    q.push_front(to);
                } else {
                    q.push_back(to);
                }
            }
        }
    }

    return dist;
}
```

# 1-k BFS

**Задача**: вам дан взвешенный граф $G$, веса рёбер которого принимают значения от $1$ до $k$ и выделена вершина $s$ в нём. Вас просят найти в этом графе кратчайшие расстояния от $s$ до всех остальных вершин.

### Наблюдение

Поскольку в графе нет рёбер отрицательного веса, то максимальное кратчайшее расстояние в нём равно $(|V| - 1) \times k$.

### Предложение

Давайте для каждого расстояния $d$ заведём $at\_dist[d]$  — очередь вершин, которые находятся на таком расстоянии от $s$ плюс, возможно, некоторые вершины, до которых существует путь длины$d$  от $s$, но для которых существует более короткий путь. Получится $(|V| - 1) \times k$ очередей.

Как посчитать эти очереди?

#### База

$at\_dist[0] = \{s\}$

#### Шаг

Если вершина $v$ лежит в списке $at\_dist[d]$, то любой из её ранее не посещённых соседей, достижимых по ребру веса $w$ лежит в списке с номером не более $at\_dist[d+w]$. Давайте тогда её добавим в этот список. Однако, надо помнить, что на самом деле кратчайшее расстояние до неё может быть и меньше, чем $d+w$.

### Теорема

Если для всех вершин до уровня $d$ расстояния посчитаны корректно, то на уровне $d+1$ сейчас находятся те вершины, до которых расстояние равно $d+1$ плюс, возможно, дубликаты вершин, до которых мы в какой-то момент нашли путь длины $d+1$, а затем нашли более короткий (разумеется, более длинные пути мы не будем рассматривать).

### А нужно ли нам так много списков?

Заметим, что на самом деле мы можем обойтись $k+1$ списками, поскольку обрабатывая рёбра, мы никогда не уходим вперёд на более, чем $k$ очередей, а старые очереди мы тем более не используем. Поэтому вместо добавления в $at\_dist[d+w]$ мы будем добавлять в $at\_dist[(d+w) \% (at\_dist.size())]$.

### Сложность алгоритма

$O(k|V| + |E|)$, поскольку каждую вершину мы можем прорелаксировать( найти более оптимальный ответ) и добавить в другую очередь не более $k$ раз, а просматривать рёбра, исходящие из вершины мы будем только когда обнаружим эту вершину в самый первый раз.

## Множественный BFS

Заметим, что добавив в очередь изначально не одну, а несколько вершин, мы найдем для каждой вершины кратчайшее расстояние до одной из них. 

---

## Еще одна задача

Попытаемся из каждой вершины найти кратчайший цикл, проходящий через неё, с помощью $BFS$. Это делается аналогично обычному $BFS$: мы должны найти расстояний от вершины до самой себя, при этом не считая, что оно равно $0$.

Итого, у нас $|V|$ запусков BFS, и каждый запуск работает за $O(|V| +
|E|)$. Тогда общее время работы составляет $O(|V|^2 + |V| |E|)$. Если инициализировать массив $dist$ единожды, а после каждого запуска BFS возвращать исходные значения только для достижимых вершин, решение будет работать за $O(|V||E|)$.
