---
title: Быстрая сортировка
weight: 5
draft: true
---

Быстрая сортировка заключается в том, что на каждом шаге мы находим опорный элемент, все элементы, которые меньше его кидаем в левую часть, остальные в правую, а затем рекурсивно спускаемся в обе части.

```cpp
// partition - функция разбивающие элементы 
// на меньшие и больше/равные a[index], 
// при этом функция возвращает границу разбиения
void partition(int l, int r, int p) {

}

void quicksort(int l, int r){
    if (l < r){
        int index = (l + r) / 2; /* index - индекс опорного элемента для 
        начала сделаем его равным середине отрезка*/
        index = partition(l, r, index);
        quicksort(l, index);
        quicksort(index + 1, r);
    }
}
```

Давайте оценим асимптотику данной сортировки. На случайных данных она работает за $O(NlogN)$ , так как каждый раз мы будем делить массив на две примерно равные части, то есть суммарно размер рекурсии будет около логарифма и при этом на каждом этапе рекурсии мы просмотрим не более, чем размер массива.
 Однако можно легко найти две проблемы, одна - одинаковые числа, а вторая - если вдруг середина - минимум или максимум.

Существуют несколько выходов из этой ситуации :

1. Давайте если быстрая сортировка работает долго, то запустим любую другую сортировку за $NlogN$.
2. Давайте делить массив не на две, а на три части(меньше, равны, больше).
3. Чтобы избавиться от проблемы с максимумом/минимумом в середине, давайте **брать случайный элемент**.
