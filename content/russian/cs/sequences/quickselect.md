---
title: Порядковые статистики
weight: 4
draft: true
---

Если в [начале предыдущей главы](/cs/interactive/binary-search) мы искали число элементов массива, меньших $x$ — также известное как индекс этого элемента в отсортированном массиве — то теперь нас интересует обратная задача: узнать, какой элемент $k$-тый по возрастанию.

Если массив уже отсортирован, то задача тривиальная: просто берем $k$-тый элемент. Иначе мы его можем отсортировать, но на это потребуется $O(n \log n)$ операций — и мы знаем, что если мы используем только сравнения, быстрее не получится.

Есть другой подход — мы можем модифицировать алгоритм быстрой сортировки.

## Quickselect

Порядковые статистики — это обобщенное название для статистик вроде медиан, квартилей, перцентилей, $k$-того большего, $k$-того меньшего и так далее.

Пусть дан массив $a$ длины $n$ и число $k$. Для простоты предположим, что все числа различные. Задача заключается в том, чтобы найти в этом массиве $k$-ое по величине число, то есть $k$-ую порядковую статистику.

В быстрой сортировке, после того как мы выбрали случайный пивот $p$ и разделили массив на две части, мы узнаем, сколько элементов меньше $p$. Дальше рассмотрим три случая:

1. Количество чисел, не превосходящих $p$, строго больше $k$. Тогда рекурсивно спускаемся в *левую* часть и ищем там $k$-ое число.
2. Количество чисел, не превосходящих $p$, строго меньше $k$. Тогда рекурсивно спускаемся в *правую* часть и ищем там $(k - |L| - 1)$-ое число.
3. Количество чисел, не превосходящих $p$, ровно $k$. Тогда $p$ — ответ на задачу.

Таким образом, алгоритм Quickselect решает эту задачу, причем в отличие от Quicksort, запускается только от одной половины, а не от двух.

Подумав над тем, что размер отрезка каждый раз убывает приблизительно в 2 раза, над ограниченностью суммы $n + \frac{n}{2} + \frac{n}{4} + \ldots = 2 \cdot n$, и немного помахав руками, получаем, что алгоритм работает за $O(n)$. 

<!--
```c++
int buffer[maxn];

int quickselect(int *a, int n) {
    int t = rand() % n;

    for ()

}
```
-->

В C++ этот алгоритм уже реализован и доступен как `nth_element`.
