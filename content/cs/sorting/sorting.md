# Сортировки и O-нотация

Задача сортировки массива заключается в том, чтобы расставить его элементы в определённом порядке (чаще всего — по неубыванию: каждый элемент должен быть больше или равен предыдущему).

Будет полезно вместе с описанем алгоритмов смотреть их [визуализацию](https://visualgo.net/nl/sorting).

### Сортировка пузырьком

Наш первый подход будет заключаться в следующем: обозначим за $n$ длину массива и $n$ раз пройдёмся раз пройдемся по нему, меняя два соседних элемента, если первый больше второго.

Как каждую итерацию максимальный элемент «всплывает» словно пузырек к концу массива — отсюда и название.

```python
void bubble_sort(vector<int>& array) {
    int n = (int) array.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - 1; j++) {
            // сравниваем элемент со следующим
            // и меняем местами, если следующий меньше
            if (array[j] > arr[j + 1]) {
                swap(array[j], array[j + 1]);
            }
        }     
    }
}

vector<int> a = {1, -3, 7, 88, 7};
bubble_sort(a);
for (auto elem : a) {
    cout << elem << " ";
}
// -3 1 7 7 88
```

После $i$ шагов алгоритма сортировки пузырьком последние $(i + 1)$ чисел всегда отсортированы, а значит алгоритм работает корректно.

**Упражнение.** Алгоритм можно немного ускорить. Подумайте, какие лишние элементы мы перебираем. Как нужно изменить границы в двух циклах `for`, чтобы не делать никаких бесполезных действий?

### Сортировка выбором

Другим способом является **сортировка выбором** минимума (или максимума).

Чтобы отсортировать массив, просто $n$ раз выберем минимум среди еще неотсортированных чисел и поставим его на свое место. На $i$-ом шаге будем искать минимум на отрезке $[i, n - 1]$ и менять его местами с $i$-тым элементом, после чего отрезок $[0, i]$ будет отсортирован.

Содержательная часть будет выглядеть так:

```cpp
for (i = 0; i < n - 1; i++) {
    for (j = i + 1; j < n; j++) {
        if (a[i] > a[j]) {
            swap(a[j], a[i]);
        }
    }
}
```

### Сортировка вставками

**Определение.** *Префиксом* длины $i$ будем называть первые $i$ элементов массива. 

Тогда пусть на $i$-ом шаге у нас уже будет отсортирован префикс до $i$-го элемента. Чтобы этот префикс увеличить, нужно взять элемент, идущий после него, и менять с левым соседом, пока этот элемент наконец не окажется больше своего левого соседа. Если в конце он больше левого соседа, но меньше правого, то это будет означать, что мы правильно вставили этот элемент в отсортированную часть массива.

```
for (int i = 1; i < n; i++) {
    for (int j = i; j > 0; j--) {
        if (a[j - 1] < a[j]) {
            break;
        }
        swap(a[j], a[j - 1]);
    }
}
```

### Сортировка подсчетом

Предыдущие три алгоритма работали с массивами, в которых лежат абсолютно любые объекты, которые можно сравнивать: любые числа, строки, пары, другие массивы — почти все что угодно.

Но особых случаях, когда элементы принадлежат какому-то маленькому множеству, можно использовать другой алгоритм — *сортировку подсчетом*.

Пусть, например, нам гарантируется, что все числа натуральные и лежат в промежутке от $1$ до $100$. Тогда есть такой простой алгоритм:

* Создадим массив размера $100$, в котором будем хранить на $k$-ом месте, сколько раз число $k$ встретилось в этом массиве.

* Пройдемся по всем числам исходного массива и увеличим соответствующее значение массива на $1$.

* После того, как мы посчитали, сколько раз каждое число встретилось, можно просто пройтись по этому массиву и вывести $1$ столько раз, сколько встретилась $1$, вывести $2$ столько раз, сколько встретилась $2$, и так далее.

*Время работы* такого алгоритма составляет $O(M+N)$, где $M$ — число возможных значений, $N$ — число элементов в массиве. Сейчас мы расскажем, что же это означает.

## О-нотация

Часто требуется оценить, сколько времени работает алгоритм. Но тут возникают проблемы:

* на разных компьютерах время работы всегда будет слегка отличаться;
* чтобы измерить время, придётся запустить сам алгоритм, но иногда приходится оценивать алгоритмы, требующие часы или даже дни работы. 

Зачастую основной задачей программиста становится оптимизировать алгоритм, выполнение которого займёт тысячи лет, до какого-нибудь адекватного времени работы. Поэтому хотелось бы уметь предсказывать, сколько времени займёт выполнение алгоритма ещё до того, как мы его запустим.

Для этого сначала попробуем оценить *число операций* в алгоритме. Возникает вопрос: какие именно операции считать. Как один из вариантов — учитывать любые элементарные операции:

* арифметические операции с числами: `+, -, *, /`
* сравнение чисел: `<, >, <=, >=, ==, !=`
* присваивание: `a[0] = 3`

При этом надо учитывать, как реализованы некоторые отдельные вещи в самом языке. Например, в питоне срезы массива (`array[3:10]`) копируют этот массив, то есть этот срез работает за 7 элементарных действий. А `swap`, например, может работать за 3 присваивания. 

**Упражнение.** Попробуйте посчитать точное число **сравнений** и **присваиваний** в сортировках пузырьком, выбором, вставками и подсчетом в худшем случае (это должна быть какая формула, зависящая от $n$ — длины массива).

Чтобы учесть вообще все элементарные операции, ещё надо посчитать, например, сколько раз прибавилась единичка внутри цикла `for`. А ещё, например, строчка `n = len(array)` — это тоже действие.  Поэтому даже посчитав их, сразу очевидно, какой из этих алгоритмов работает быстрее — сравнивать формулы сложно. Хочется придумать способ упростить эти формулы так, чтобы:

* не нужно было учитывать много информации, не очень сильно влияющей на итоговое время;
* легко было оценивать время работы разных алгоритмов для больших чисел;
* легко было сравнивать алгоритмы на предмет того, какой из них лучше подходит для тех или иных входных данных.

Для этого придумали *$O$-нотацию* — асимптотическое время работы вместо точного (часто его ещё называют асимптотикой). 

**Определение.** Пусть $f(n)$ - это какая-то функция. Говорят, что алгоритм работает за $O(f(n))$, если существует число $C$, такое что алгоритм работает не более чем за $C \cdot f(n)$ операций.

В таких обозначениях можно сказать, что

* сортировка пузырьком работает за $O(n^2)$;
* сортировка выбором работает за $O(n^2)$;
* сортировка вставками работает за $O(n^2)$;
* сортировка подсчетом работает за $O(n + m)$.

Это обозначение удобно тем, что оно короткое и понятное, а также оно не зависит от умножения на константу или прибавления константы. Например, если алгоритм работает за $O(n^2)$, то это может значить, что он работает за $n^2$, за $n^2 + 3$, за $\frac{n(n-1)}{2}$ или даже за $1000 \cdot n^2 + 1$ действие. Главное — что функция ведет себя как $n^2$, то есть при увеличении $n$ (в данном случае это длина массива) он увеличивается как некоторая квадратичная функция. Например, если увеличить $n$ в 10 раз, время работы программы увеличится приблизительно в 100 раз.

Все рассуждения про то, сколько операций в `swap` или считать ли отдельно присваивания, сравнения и циклы — отпадают. Каков бы ни был ответ на эти вопросы, они меняют ответ лишь на константу, а значит асимптотическое время работы алгоритма никак не меняется.

Первые три сортировки именно поэтому называют **квадратичными** — они работают за $O(n^2)$. Сортировка подсчетом может работать намного быстрее — она работает за $O(n + m)$, а если в задаче $M \leq N$, то это вообще линейная функция $O(n)$.

**Упражнение.** Найдите асимптотику данных функций, маскимально упростив ответ (например, до $O(n)$, $O(n^2)$ и т. д.):

* $\frac{N}{3}$
* $\frac{N(N-1)(N-2)}{6}$
* $1 + 2 + 3 + \ldots + N$
* $1^2 + 2^2 + 3^2 + \ldots + N^2$
* $\log{N} + 3$
* $179$
* $10^{100}$

**Упражнение.** Найдите асимптотическое время работы данных функций:

```python
def f(n):
    s = 0
    for i in range(n):
        for j in range(n):
            s += i * j
    return s
```

```python
def g(n):
    s = 0
    for i in range(n):
        s += i
    for i in range(n):
        s += i * i
    return s
```

```python
def h(n):
    if n == 0:
        return 1
    return h(n - 1) * n
```

**Упражнение.** Найдите лучшее время работы алгоритмов, решающих данные задачи:

* Написать числа от $1$ до $n$.
* Написать все тройки чисел от $1$ до $n$.
* Найти разницу между максимумом и минимумом в массиве.
* Найти число единиц в бинарной записи числа $n$.

## Сортировки за $O(n \log n)$

Сортировка очень часто применяется как часть решения олимпиадных задач. В таких случаях обычно не пишут её заново, а используют встроенную.

Пример на Python:

```python
a = [1, 5, 10, 5, -4]
a.sort()
```

Пример на C++:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int main() {
    vector<int> v = {1, 5, 10, 5, -4};
    sort(v.begin(), v.end());
}
```

В разных языках она может быть реализована по-разному, но везде она работает за $O(n \log n)$, и, обычно, неплохо оптимизирована. Далее мы опишем два подхода к её реализации.

## Сортировка слиянием

> Найти количество пар элементов $a$ и $b$ в отсортированном массиве, такие что $b - a > K$.

Наивное решение: бинарный поиск. Будем считать, что массив уже отсортирован. Для каждого элемента $a$ найдем первый справа элемент $b$, который входит в ответ в паре с $a$. Нетрудно заметить, что все элементы, большие $b$, также входят в ответ. Итоговая асимптотика $O(n\log n)$.

А можно ли быстрее?

Да, давайте перебирать **два указателя** — два индекса $first$ и $second$. Будем перебирать $first$ просто слева направо и поддерживать для каждого $first$ первый элемент справа от него, такой что $a[second] - a[first] > K$ как $second$. Тогда в пару к $a=a[first]$ подходят ровно $n-second$ элементов массив начиная с $second$.

```cpp
int second = 0, ans = 0;
for (int first = 0; first < n; ++first) {
    while (second != n && a[second] - a[first] <= r) {
        second++;
    }

    ans += n - second;
}
```

За сколько же работает это решение? С виду может показаться, что за $O(n^2)$, но давайте посмотрим сколько раз меняется значение переменной $second$. Так как оно изначально равняется нулю, только увеличивается и не может превысить $n$, то суммарно операций мы сделаем $O(n)$.

Это называется метод двух указателей — так как мы двигаем два указателя first и second одновременно слева направо по каким-то правилам. Обычно его используют на одном отсортированном массиве.

Давайте разберем еще примеры.

## Слияние

Еще пример двух указателей на нескольких массивах.

Пусть у нас есть два отсортированных по неубыванию массива размера $n$ и $m$. Хотим получить отсортированный массив размера $n + m$ из исходных.

Пусть первый указатель будет указывать на начало первого массива, а второй, соответственно, на начало второго. Из двух текущих элементов, на которые указывают указатели, выберем наименьший и положим на соответствующую позицию в новом массиве, после чего сдвинем указатель. Продолжим этот процесс пока в обоих массивах не закончатся элементы. Тогда код будет выглядеть следующим образом:

```cpp
int a[n + 1], b[m + 1], res[n + m];

a[n] = INF; // Создаем в конце массива фиктивный элемент, который заведомо больше остальных
b[m] = INF; // Чтобы избежать лишних случаев

for (int i = 0; i < n; ++i) {
    cin >> a[i];
}

for (int j = 0; j < m; ++j) {
    cin >> a[j];
}

int i = 0, j = 0;
for (int k = 0; k < n + m; ++k) {
    if (a[i] < b[j]) {
        res[k] = a[i];
        i++;
    } else {
        res[k] = b[j];
        j++;
    }
}
```

Итоговая асимптотика: $O(n + m)$.

## Сортировка слиянием

Давайте подробно опишем как использовать операцию слияния для сортировки за $O(n\log n)$.

Пусть у нас есть какой-то массив.

```cpp
int a[8] = {7, 2, 5, 6, 1, 3, 4, 8};
```

Сделаем такое предположение. Пусть мы уже умеем как-то сортировать массив размера $n$. Тогда научимся сортировать массив размера $2n$.
Давайте разобьем наш массив на две половины, отсортируем каждую из них, а после это сделаем слияние двух массивов, которое мы научились делать за $O(n)$ в данных условиях. Также заметим, что массив размера $1$ уже отсортирован, тогда мы можем делать это процедуру рекурсивно. Тогда для данного массива $a$ это будет выглядеть следующим образом:

```cpp
// (7  2  5  6  1  3  4  8)
// (7  2  5  6)(1  3  4  8)
// (7  2)(5  6)(1  3)(4  8)
// (2  7)(5  6)(1  3)(4  8)
// (2  5  6  7)(1  3  4  8)
// (1  2  3  4  5  6  7  8)

#include  // Воспользуемся встроенной функцией merge

void merge_sort(vector &v, int l, int r) { // v - вектор, который хотим отсортировать
    if (r - l == 1) {                            // l и r - полуинтервал, который хотим отсортировать
        return;
    }

    int mid = (l + r) / 2;
    merge_sort(v, l, mid);
    merge_sort(v, mid, r);
    vector temp(r - l); // временный вектор
    merge(v.begin() + l, v.begin() + mid, v.begin() + mid, v.begin() + r, c.begin());
    for (int i = 0; i < r - l; ++i) {
        v[i + l] = temp[i];
    }
    return;
}
```

Так сколько же работает это решение?

Пускай $T(n)$ — время сортировки массива длины $n$, тогда для сортировки слиянием справедливо $T(n)=2T(n/2)+O(n)$
 $O(n)$ — время, необходимое на то, чтобы слить два массива длины n. Распишем это соотношение:

$T(n)=2T(n/2)+O(n)=4T(n/4)+2O(n)=\ldots=T(1)+\log(n)O(n)=O(n\log(n)).$

## Количество инверсий

Пусть у нас есть некоторая перестановка $a$. Инверсией называется пара индексов $i$ и $j$ такая, что $i < j$ и $a[i] > a[j]$.

> Найти количество инверсий в данной перестановке.

Очевидно, что эта задача легко решается обычным перебором двух индексов за $O(n^2)$:

```cpp
int a[n], ans = 0;

for (int i = 0; i < n; ++i) {
    for (int j = i + 1; j < n; ++j) {
        if (a[i] > a[j]) {
            ans++;
        }
    }
}

cout << ans << endl;
```

Внезапно эту задачу можно решить используя сортировку слиянием, слегка модифицируя её. Оставим ту же идею. Пусть мы умеем находить количество инверсий в массиве размера $n$, научимся находить количество инверсий в массиве размера $2n$.

Заметим, что мы уже знаем количество инверсий в левой половине и в правой половине массива. Осталось лишь посчитать число инверсий, где одно число лежит в левой половине, а второе в правой половине. Как же их посчитать?

Давайте подробнее рассмотрим операцию merge левой и правой половины (которую мы ранее заменили на вызов встроенной функции merge). Первый указатель указывает на элемент левой половины, второй указатель указывает на элемент второй половины, мы смотрим на минимум из них и этот указатель вдигаем вправо.

Рассмотрим число $A$ в левой половине. В скольки инверсиях между половинами оно участвует? В стольки, сколько чисел в правой половине меньше, чем оно. Знаем ли мы это количество? Да! Ровно в тот момент, когда мы число $A$ вносим в слитый массив, второй указатель указывает на первое число в правой половине, которое больше чем $A$.

Значит в тот момент, когда мы добавляем число $A$ из левой половины, к ответу достаточно прибавить индекс второго указателя (минус начало правой половины). Так мы учтем все инверсии между половинами.

# Быстрая сортировка

Быстрая сортировка заключается в том, что на каждом шаге мы находим опорный элемент, все элементы, которые меньше его кидаем в левую часть, остальные в правую, а затем рекурсивно спускаемся в обе части.

```cpp
void quicksort(int l, int r){
    if (l < r){
        int index = (l + r) / 2; /* index - индекс опорного элемента для 
        начала сделаем его равным середине отрезка*/
        index = divide(l, r, index); /* divide - функция разбивающие элементы 
        на меньшие и больше/равные a[index], 
        при этом функция возвращает границу разбиения*/
        quicksort(l, index);
        quicksort(index + 1, r);
    }
}
```

Давайте оценим асимптотику данной сортировки. На случайных данных она работает за $O(NlogN)$ , так как каждый раз мы будем делить массив на две примерно равные части, то есть суммарно размер рекурсии будет около логарифма и при этом на каждом этапе рекурсии мы просмотрим не более, чем размер массива.
 Однако можно легко найти две проблемы, одна - одинаковые числа, а вторая - если вдруг середина - минимум или максимум.

Существуют несколько выходов из этой ситуации :

2. Давайте если быстрая сортировка работает долго, то запустим любую другую сортировку за $NlogN$.

3. Давайте делить массив не на две, а на три части(меньше, равны, больше).

4. Чтобы избавиться от проблемы с максимумом/минимумом в середине, давайте **брать случайный элемент**.

### Поиск $k$-ой порядковой статистики за $O(N)$

Пусть дан массив $A$ длиной $N$ и пусть дано число $K$. Задача заключается в том, чтобы найти в этом массиве $K$-ое по величине число, т.е. $K$-ую порядковую статистику.

Давайте поймем, что в быстрой сортировке мы можем узнать, сколько элементов меньше данного, тогда рассмотрим три случая

2. количество чисел, меньше данного = $k - 1$, тогда наше число - ответ.

3. количество чисел, меньше данного >= $k$, тогда спускаемся рекурсивно в левую часть и ищем там ответ.

4. количество чисел, меньше данного < $k$, спускаемся в правую ищем ($k$ - левая - 1) - ое число.

За сколько же это работает, из быстрой сортировки мы имеем, что размер убывает приблизительно в 2 раза, то есть мы имеем сумму $\sum_{k=1}^n {2 ^ k} = {2^{k+1}-1}$ что в нашем случае это максимум равно $2 * N - 1$, то есть $O(N)$.

Также в C++ эта функция уже реализована и называется `nth_element` .
